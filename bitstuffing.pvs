bitstuffing: THEORY
BEGIN
    % Aus USB-Standard Revision 1.1 September 23, 1998 (esd.cs.ucr.edu/webres/usb11.pdf)
    %
    % 7.1.9: Bitstuffing
    %
    % "A zero is inserted after every six consecutive ones in the data
    % stream before the data is NRZI encoded, to force a transition in
    % the NRZI data stream."
    %
    % "The receiver must decode the NRZI data, recognize the stuffed bits,
    % and discard them. If the receiver sees seven consecutive ones
    % anywhere in the packet, then a bit stuffing error has occurred and
    % the packet should be ignored."
    %
    % Also kurz:
    % * nach 6 aufeinanderfolgenden Einsen wird eine 0 eingefügt --> stuffing
    % * unstuffing -> 0 nach 6 aufeinanderfolgenden Einsen erkennen und entfernen
    %
    % Beispiel:
    % unstuffed: 0110111111101
    % stuffed:   01101111110101
    %
    % Im Beweis wird nicht 6, sondern beliebige Zahl > 0 verwendet
    MAX_ONES: above(0)

    maximal(m: nat): TYPE = {n: nat | n <= m}
    between(s: nat, e: nat): TYPE = {n: nat | s <= n AND n <= e}

    % Sequenz mit beliebiger Länge
    bit_seq: TYPE = finite_sequence[bool]    
    % Sequenz mit genau n Bits
    fix_seq(n: nat): TYPE = {s: bit_seq | s`length = n}
    % Sequenzen mit mehr als oder gleich n Bits
    min_seq(n: nat): TYPE = {s: bit_seq | s`length >= n}

    % Bedingung für Ergebnis der "stuff" Funktions
    % index aus i, so dass von alle j von i + 1 bis i + max_rep - 1
    % s(j) = s(i)
    stuffed?(s: bit_seq): bool =
    	s`length <= MAX_REP OR
	(s`length > MAX_REP AND
	FORALL(start: below(s`length - MAX_REP)):		% Für alle Subsequenzen der Länge MAX_REP + 1
	    NOT (FORALL(i: between(start, start+MAX_REP-1)): 	% Nicht alle Bits sind gleich
	        s(i) IFF s(i+1)))

    fix_stuffed(l: nat): TYPE = {s: fix_seq(l) | stuffed?(s)}
    min_stuffed(l: nat): TYPE = {s: min_seq(l) | stuffed?(s)}

    % Wrapper um genau ein Element
    single(el: bool): fix_seq(1) =
        (# length := 1, seq := LAMBDA(i: below(1)): el #)

    % Alle Bits außer das erste
    tail(s: min_seq(1)): fix_seq(s`length-1)  =
        s ^^ (1, s`length)

    % Füge Bit als "Kopf" an eine Sequenz an
    cons(head: bool, tail: bit_seq): fix_seq(tail`length + 1) =
        single(head) o tail

    % ==== CONS HELPER ===

    % PVS über Sequenzen "schlaumachen"
    % Beweis über expanden der ganzen Funktionen
    cons_first: FORMULA
        FORALL(b: bool, tail: bit_seq):
	    b IFF (cons(b,tail)(0))

    % Beweis über expanden der ganzen Funktionen
    cons_first_tail: FORMULA
        FORALL(b: bool, tail: min_seq(1)):
	    tail(0) IFF cons(b, tail)(1)

    % Beweis über expanden der ganzen Funktionen
    cons_length: FORMULA
        FORALL(head: bool, tail: bit_seq):
	    cons(head, tail)`length = tail`length + 1

    % Wie oben
    cons_get: FORMULA
        FORALL(head: bool, tail: bit_seq)(i: between(0, tail`length-1)):
	     tail(i) IFF cons(head, tail)(i+1)

    % Wie oben
    cons_get_2: FORMULA
        FORALL(head: bool, tail: bit_seq, i: below(tail`length-1)):
	    cons(head, tail)(i) =
	        IF i = 0 THEN head ELSE
		tail(i-1) ENDIF

    % ==== TAIL HELPER ====

    tail_length: FORMULA
        FORALL(seq: min_seq(1)):
	    tail(seq)`length = seq`length - 1

    tail_get: FORMULA
        FORALL(seq: min_seq(2), i: between(1, seq`length-2)):
	    seq(i) = tail(seq)(i-1)

    only_zero: AXIOM
        FORALL(x: bit_seq):
	    (x`length = 0) IMPLIES x = empty_seq

    zeros_equal: AXIOM
        FORALL(x: bit_seq, y: bit_seq):
	    (x`length = 0 AND y`length = 0)
	        IMPLIES (x = y)

    % PROBLEM: lässt sich nicht beweisen
    tail_cons: AXIOM
        FORALL(head: bool, seq: bit_seq):
	    seq = tail(cons(head, seq))

    % ==== FORMULAS ====
    % Wenn ich Element an stuffed Liste anhänge, ist dies auch stuffed wenn:
    % 	   * tail`length < MAX_REP ist
    % Beweis über Länge: tail`length + 1 <= MAX_REP 
    cons_smaller: FORMULA
        FORALL(head: bool, tail: (stuffed?)):
	    (tail`length < MAX_REP) IMPLIES
	        stuffed?(cons(head,tail))

    % Wenn ich Seqeunzen mit cons verbinde und Ersten MAX_REP-1 Elemente von
    % head verschieden sind ist wieder (stuffed?) erfüllt
    % Beweis mit (case start=0) und dann mit cons_get und cons_first benutzen   
    cons_stuffed: FORMULA
        FORALL(head: bool, tail: min_stuffed(MAX_REP+1)):
            LET c = cons(head, tail) IN
	    (NOT (FORALL(i: between(0, MAX_REP-2)): c(i) IFF c(i+1))) IMPLIES
	         stuffed?(c)
		
    % Wenn ich Element an stuffed Liste anhänge, ist dies auch stuffed wenn:
    %	   * head ungleich ersten Element von tail ist
    % Beweis: Head ist unterschiedlich zu tail(0) -> also muss Eigenschaft erfüllt sein
    % Beweis über cons_stuffed 
    cons_xor: FORMULA
        FORALL(head: bool, tail: min_stuffed(MAX_REP+1)):
	    (head XOR tail(0)) IMPLIES
	        stuffed?(cons(head,tail))

    % Tail von einer "stuffed" Sequenz ist immer auch Stuffed
    tail_stuffed: FORMULA
        FORALL(s: min_stuffed(1)):
	    stuffed?(tail(s))

    % stuffed bit_seq an die ich immer vorne ein beliebiges bit anhängen kann
    % und sie dann immer noch stuffed ist
    consable?(s: bit_seq): bool =
        s`length < MAX_REP OR
	(s`length >= MAX_REP AND
	NOT FORALL(i: between(0, MAX_REP-2)): % Die ersten MAX_REP-1 Bits dürfen nicht gleich sein
	    s(i) IFF s(i+1))

    % Kombination von stuffed? und consable?
    stuffed_consable: TYPE = {s: bit_seq |
        consable?(s) AND stuffed?(s)
    }

    % wenn irgend ein bit an stuffed_consable angehängt wird ist dies immer noch stuffed?
    consable_stuffed: FORMULA % Problem Ungleichheit immer am 0.Bit festgemacht
        FORALL(s: stuffed_consable, b: bool):
	    stuffed?(cons(b, s))

    cons_consable: FORMULA
        FORALL(head: bit, tail: (consable?)):
	    consable?(cons(NOT head, cons(head, tail)))

    %cons_consable_2: FORMULA
    %    FORALL(head: bit, tail: (consable?)):
    %	    (NOT FORALL(i: between(0, MAX_REP-2): head IFF tail(MAX_REP))  IMPLIES
    %	        consable?(cons(bit, tail))

    % Beweis über cons
    % wenn bei stuff rep_count > 0 hat Ergebnis nicht mehr als MAX_REP - rep_count gleiche Bits am Anfange
    % -> also kann man s(0) anhägen
    % Fall1: da s(0) negiert wird -> cons_xor
    stuff(s: bit_seq, one_count: nat): RECURSIVE min_seq(s`length) =
        IF s`length = 0 THEN
	    empty_seq
	ELSE
	    IF one_count >= MAX_REP THEN
	        cons(s(0), cons(false, stuff(tail(s), 0))) % Fall 1
	    ELSE
		LET new_count = IF s(0) IFF rep_bit THEN rep_count+1 ELSE 1 ENDIF IN
	            cons(s(0), stuff(tail(s), new_count, s(0))) % Fall 2
	    ENDIF
	ENDIF
    MEASURE s`length

    %get_i(seq: bit_seq, i: nat): RECURSIVE bool =
    %	IF seq`length = 1 THEN
    %	    seq(0) ELSE
    %	    get_i(tail(seq), i-1) ENDIF
    %MEASURE seq`length

    %get_i_tail: FORMULA
    %    FORALL(seq: min_seq(3), i: nat):
    %        get_i(seq, i) = get_i(tail(seq), i-1)

    len(seq: min_seq(1)): RECURSIVE nat =
        IF seq`length <= 1 THEN
    	1 ELSE
    	1 + len(tail(seq)) ENDIF
    MEASURE seq`length

    induct_test_1: FORMULA
        FORALL(seq: min_seq(1)):
    	    seq`length = len(seq)

    filter(seq: bit_seq): RECURSIVE bit_seq = 
        IF seq`length = 0 THEN empty_seq
	ELSE
	    IF seq(0) THEN
	    cons(true, filter(tail(seq))) ELSE
	    filter(tail(seq)) ENDIF
	ENDIF
    MEASURE seq`length

    induct_test_2: FORMULA
        FORALL(seq: bit_seq):
	    LET res = filter(seq) IN
	    FORALL(i: below(res`length)):
	        res(i)

    %induct_test_2: FORMULA
    %    FORALL(seq: bit_seq, i: below(seq`length)):
    %	    seq(i) = get_i(seq, i)
 
    % wenn ich stuff mit rep_count > 0 und korrekten parametern aufrufe,
    % dann ist das ergebnis immer consable?
    stuff_consable: FORMULA
        FORALL(s: bit_seq, rep_count: between(1, s`length-1)):
	    (FORALL(i: between(0, rep_count-1)): s(i) IFF s(i+1) % rep_count ist #gleicher Bits am Anfang von s 
	    	IMPLIES consable?(stuff(tail(s), rep_count, s(0))))

    % Wenn stuff mit richtigen Startparameter aufgerufen wird, ist das Ergebnis
    % stuffed
    stuff_works: FORMULA
        FORALL(s: bit_seq):
	    stuffed?(stuff(s, 0, False))
	    

    unstuff(s: bit_seq, rep_count: nat, rep_bit: bool): RECURSIVE bit_seq =
        IF s`length = 0 THEN
	    empty_seq
	ELSE
	    IF rep_count >= MAX_REP-1 AND s(0) IFF rep_bit THEN
	        cons(s(0), unstuff(tail(tail(s)), 0, False))
	    ELSE
	        LET new_count = IF s(0) IFF rep_bit THEN rep_count+1 ELSE 1 ENDIF IN
		    cons(s(0), unstuff(tail(s), new_count, s(0)))
    	    ENDIF
	ENDIF
    MEASURE s`length

%    stuff_result: FORMULA
%        FORALL(s: bit_seq):
%	    stuff(s, 0, False) = IF (stuffed?(s)) THEN
%	        s ELSE 

    stuffed_correct: FORMULA 
        FORALL(s: (stuffed?)):
	    s = unstuff(stuff(s, 0, False), 0, False)

    correct: FORMULA
        FORALL(s: bit_seq):
	    s = unstuff(stuff(s, 0, False), 0, False)
    
END bitstuffing
