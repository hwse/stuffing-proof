bitstuffing: THEORY
BEGIN
    % maximale Wiederholungen von Bits in einer "stuffed" Bitsequenz
    % Bsp: max_rep = 4
    % 100001 -> Okay da 4 wiederholende Nullen
    % 100000 -> Nicht Okay, wird von stuff-Funktion umgewandelt zu:
    % 1000010
    max_rep: nat

    % Länge der Sequenzen
    unstuffed_len: nat
    stuffed_len: nat

    % Mögliche Indizes für eine Sequenz
    unstuffed_index: TYPE = {i: nat | i < unstuffed_len}
    stuffed_index: TYPE = {i: nat | i < stuffed_len}  

    %  "unstuffed" Bitsequenz
    unstuffed_bit_seq: TYPE = [unstuffed_index->bool]
    
    % Abschnitt der "stuffed" Sequenz
    range: TYPE = {r: [stuffed_index, stuffed_index] | r`1 <= r`2 }
    range_len(r: range): nat = r`2 - r`1
    % Alle Indizes in der Sequenz
    range_indices(r: range): TYPE = {i: stuffed_index | r`1 <= i AND i < r`2}

    % In der Bitsequenz ist die Anzahl gleicher aufeinandender Bits <= max_rep
    stuffed?(s: [stuffed_index->bool]): bool =
    	NOT EXISTS(r: range):
	    range_len(r) > max_rep AND
	    FORALL(i: range_indices(r)):
	        s(i) IFF s(0)	% Nicht alle Bits dürfen gleich (dem 0ten) sein 
	    
    % "stuffed" Bitsequenz
    stuffed_bit_seq: TYPE = { s: [stuffed_index->bool] | stuffed?(s) }

    % Hilfstype um bereits bekannten Wiederholungen zu merken
    % [Gemerkte Wiederholungen, Wiederholte Bit]
    rep_info: TYPE = [#count: nat, bit: bool#]

    % Sequenzoperationen
    tail(s: unstuffed_bit_seq): unstuffed_bit_seq =
    	LAMBDA(i: unstuffed_index):
	     s(i+1)
	     
    zero: stuffed_index = 0
    %cons(bit: bool, s: stuffed_bit_seq): stuffed_bit_seq =
    %	LAMBDA(i: stuffed_index):
    %	     IF i == 0 THEN bit ELSE s(i) ENDIF

    stuff(s: unstuffed_bit_seq, ri: rep_info): stuffed_bit_seq %=
    %    IF ri`count >= max_rep AND s()
    %	THEN
    %	ELSE stuff()
    unstuff(ss: stuffed_bit_seq, ri: rep_info): unstuffed_bit_seq
    
END bitstuffing
