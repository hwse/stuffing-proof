bitstuffing: THEORY
BEGIN
    % maximale Wiederholungen von Bits in einer "stuffed" Bitsequenz
    % Bsp: max_rep = 4
    % 100001 -> Okay da 4 wiederholende Nullen
    % 100000 -> Nicht Okay, wird von stuff-Funktion umgewandelt zu:
    % 1000010
    MAX_REP: posint

    maximal(m: nat): TYPE = {n: nat | n <= m}
    between(s: nat, e: nat): TYPE = {n: nat | s <= n AND n <= e}

    % Sequenz mit beliebiger Länge
    bit_seq: TYPE = finite_sequence[bool]    
    % Sequenz mit genau n Bits
    fix_seq(n: nat): TYPE = {s: bit_seq | s`length = n}
    % Sequenzen mit mehr als oder gleich n Bits
    min_seq(n: nat): TYPE = {s: bit_seq | s`length >= n}

    % Bedingung für Ergebnis der "stuff" Funktions
    % index aus i, so dass von alle j von i + 1 bis i + max_rep - 1
    % s(j) = s(i)
    stuffed?(s: bit_seq): bool =
    	s`length <= MAX_REP OR
	(s`length > MAX_REP AND
	NOT EXISTS(start: below(s`length - MAX_REP)):
	    FORALL(i: between(start+1, start+MAX_REP)):
	        s(start) IFF s(i))

    fix_stuffed(l: nat): TYPE = {s: fix_seq(l) | stuffed?(s)}
    min_stuffed(l: nat): TYPE = {s: min_seq(l) | stuffed?(s)}

    % Wrapper um genau ein Element
    single(el: bool): fix_seq(1) =
        (# length := 1, seq := LAMBDA(i: below(1)): el #)

    % Alle Bits außer das erste
    tail(s: min_seq(1)): fix_seq(s`length-1)  =
        s ^^ (1, s`length)

    % Füge Bit als "Kopf" an eine Sequenz an
    cons(head: bool, tail: bit_seq): fix_seq(tail`length + 1) =
        single(head) o tail

    % PVS über Sequenzen "schlaumachen"
    % Beweis über expanden der ganzen Funktionen
    cons_first: FORMULA
        FORALL(b: bool, tail: bit_seq):
	    b IFF (cons(b,tail)(0))

    % Beweis über expanden der ganzen Funktionen
    cons_first_tail: FORMULA
        FORALL(b: bool, tail: min_seq(1)):
	    tail(0) IFF cons(b, tail)(1)

    % Beweis über expanden der ganzen Funktionen
    cons_length: FORMULA
        FORALL(head: bool, tail: bit_seq):
	    cons(head, tail)`length = tail`length + 1

    % Wie oben
    cons_get: FORMULA
        FORALL(head: bool, tail: bit_seq)(i: between(0, tail`length-1)):
	     tail(i) IFF cons(head, tail)(i+1)

    % Wenn ich Element an stuffed Liste anhänge, ist dies auch stuffed wenn:
    % 	   * tail`length < MAX_REP ist
    % Beweis über Länge: tail`length + 1 <= MAX_REP 
    cons_smaller: FORMULA
        FORALL(head: bool, tail: (stuffed?)):
	    (tail`length < MAX_REP) IMPLIES
	        stuffed?(cons(head,tail))

    % Beweis mit (case "y=0")
    %for_helper: FORMULA
    %    FORALL(l: above(0), con: [below(l)->bool]):
    %	    (con(0) and (FORALL(x: between(1, l)): con(x))) IMPLIES
    %	         (FORALL(y: between(0, l)): con(y))

    % Wenn ich Seqeunzen mit cons verbinde und Ersten MAX_REP-1 Elemente von
    % head verschieden sind ist wieder (stuffed?) erfüllt
    % Beweis mit (case start=0) und dann mit cons_get und cons_first benutzen   
    cons_stuffed: FORMULA
        FORALL(head: bool, tail: min_stuffed(MAX_REP+1)):
            LET c = cons(head, tail) IN
            (NOT FORALL(i: between(1, MAX_REP)): head IFF tail(i-1)) IMPLIES
	        stuffed?(c)
		
    % Wenn ich Element an stuffed Liste anhänge, ist dies auch stuffed wenn:
    %	   * head ungleich ersten Element von tail ist
    % Beweis: Head ist unterschiedlich zu tail(0) -> also muss Eigenschaft erfüllt sein
    % Beweis über cons_stuffed 
    cons_xor: FORMULA
        FORALL(head: bool, tail: min_stuffed(MAX_REP+1)):
	    (head XOR tail(0)) IMPLIES
	        stuffed?(cons(head,tail))

    % Tail von einer "stuffed" Sequenz ist immer auch Stuffed
    tail_stuffed: FORMULA
        FORALL(s: min_stuffed(1)):
	    stuffed?(tail(s))

    % stuffed bit_seq an die ich immer vorne ein beliebiges bit anhängen kann
    % und sie dann immer noch stuffed ist
    consable?(s: bit_seq): bool =
        s`length < MAX_REP OR
	(s`length >= MAX_REP AND
	NOT FORALL(i: between(1, MAX_REP-1)):
	    s(0) IFF s(i))

    % Kombination von stuffed? und consable?
    stuffed_consable: TYPE = {s: bit_seq |
        consable?(s) AND stuffed?(s)
    }

    consable_cons: FORMULA
        FORALL(head: bool, tail: min_seq(2)):
            LET c = cons(head, tail) IN
	    (NOT FORALL(i: between(1, c`length-1)):
	        c(1) IFF c(i)) IMPLIES
		     (NOT FORALL(i: between(1, tail`length-1)):
		         tail(0) IFF tail(i))
	

    consable_modulo: FORMULA
        FORALL(seq: min_seq(MAX_REP), n: nat):
	    (NOT FORALL(i: between(1, MAX_REP)):
	        seq(mod(0+n, MAX_REP)) IFF seq(mod(i+n, MAX_REP))) IMPLIES
		    (NOT FORALL(i: between(1, MAX_REP)):
		        seq(0) IFF seq(i))

    % Idee: wenn NOT FORALL bzw. EXISTS in bereich gilt, kann der Bereich vergrößert werden
    % Lässt sich leicht beweisen
    forall_test: FORMULA
        FORALL(range: nat, con: [nat->bool]):
            ((NOT FORALL(n: below(range)):
	         con(n)) IMPLIES
		     (NOT FORALL(n: below(range+1)):
		         con(n)))

    % Idee: Eigenschaft: Es gibt mind. ein unterschiedliches Bit umdrehen
    % 0 IFF 1 2 3 4
    % 4 IFF 0 1 2 3
    % Beweisbar, da ein Bit mit allen anderen verglichen
    reverse_condition: FORMULA
        FORALL(c: min_seq(1), range: below(c`length), start: below(c`length)):
	    (NOT FORALL(i: between(1, range-1)):
	        c(0) IFF c(i)) IMPLIES
		    (NOT FORALL(i: between(0, range-2)):
		         c(range-1) IFF c(i))

    cons_get_2: FORMULA
        FORALL(head: bool, tail: bit_seq, i: below(tail`length-1)):
	    cons(head, tail)(i) =
	        IF i = 0 THEN head ELSE
		tail(i-1) ENDIF
    
    % Bitsequenz: in den n ersrten Bits sind nicht alle Bits gleich
    % Dann: hängt man beliebiges bit an -> gilt jene Eigenschaft für n-1
    consable_helper: FORMULA
        FORALL(n: nat, head: bool, tail: min_seq(n)):
	    (NOT FORALL(i: between(1, n-1)):
	        tail(0) IFF tail(i)) IMPLIES
		    LET c = cons(head, tail) IN
		    NOT FORALL(i: between(1, c`length-1)):
		        c(0) IFF c(i)
    % - 0 1 2 3
    % - 0 1 1 1
    % 1 2 3 4 5
    % 1 0 1 1 1

    % wenn irgend ein bit an stuffed_consable angehängt wird ist dies immer noch stuffed?
    consable_stuffed: FORMULA % Problem Ungleichheit immer am 0.Bit festgemacht
        FORALL(s: stuffed_consable, b: bool):
	    stuffed?(cons(b, s))

    % Beweis über cons
    % wenn bei stuff rep_count > 0 hat Ergebnis nicht mehr als MAX_REP - rep_count gleiche Bits am Anfange
    % -> also kann man s(0) anhägen
    % Fall1: da s(0) negiert wird -> cons_xor
    stuff(s: bit_seq, rep_count: nat, rep_bit: bool): RECURSIVE min_stuffed(s`length) =
        IF s`length = 0 THEN
	    empty_seq
	ELSE
	    IF rep_count >= MAX_REP AND s(0) IFF rep_bit THEN
	        cons(NOT s(0), cons(s(0), stuff(tail(s), 1, s(0)))) % Fall 1
	    ELSE
		LET new_count = IF s(0) IFF rep_bit THEN rep_count+1 ELSE 1 ENDIF IN
	            cons(s(0), stuff(tail(s), new_count, s(0))) % Fall 2
	    ENDIF
	ENDIF
    MEASURE s`length

    % wenn ich stuff mit rep_count > 0 und korrekten parametern aufrufe,
    % dann ist das ergebnis immer consable?
    stuff_consable: FORMULA
        FORALL(s: bit_seq, rep_count: above(0), rep_bit: bool):
	    ((FORALL(i: between(1, rep_count)): s(0) IFF s(i)) AND % rep_count ist #gleicher Bits am Anfang von s 
	    s(0) IFF rep_bit) IMPLIES		     	       	   % rep_bit das wiederholende Bit ist
	        consable?(stuff(s, rep_count, rep_bit))
		

    
    % für n > 0 gibt stuff eine Sequenz zurück, die mit wengier als MAX_REP gleichen Bits beginnt
    stuff_helper: FORMULA
        FORALL(s: bit_seq, n: between(1,MAX_REP), b: bool):
	    LET r = stuff(s, n, b) IN
	    NOT FORALL(i: between(0, MAX_REP)): 
	        r(0) IFF r(i)
	    

%    unstuff(s: (stuffed?), rep_count: nat, rep_bit: bool): RECURSIVE bit_seq =
%        IF s`length = 0 THEN
%	    empty_seq
%	ELSE
%	    IF rep_count >= MAX_REP-1 AND s(0) IFF rep_bit THEN
%	        cons(s(0), unstuff(tail(tail(s)), 0, False))
%	    ELSE
%	        LET new_count = IF s(0) IFF rep_bit THEN rep_count+1 ELSE 1 ENDIF IN
%		    cons(s(0), unstuff(tail(s), new_count, s(0)))
%    	    ENDIF
%	ENDIF
%    MEASURE s`length

%    correct: FORMULA
%        FORALL(s: bit_seq):
%	    s = unstuff(stuff(s, 0, False)`seq, 0, False)

    % Beweisidee für die tcc
    % Bei Fall 1 und Fall 2 entsteht durch das zusammenhängen eine stufffed bit_seq, denn
    % wenn wir s_0 mit stuff(s_1..n, 1, s(0)) zusammenhängen
    % beginnt stuff(s_1..n, 1, s(0)) mit max. max_rep-1 gleichen bits
    % Also entsteht durch das Zusammenhängen maximal max_rep Wiederholungen -> stuffed? ist erfüllt
    %n: VAR below(MAX_REP)
    %b: VAR bool
    %stuff_starts: FORMULA
    %    FORALL(s: min_seq(MAX_REP + 1)): %Bitsequenz bei der Stuffing nötig sein könnte   
    %	    EXISTS(i: below(MAX_REP+1-n)):	      %0..3+1-0 -> muss mindestens einer verschieden zu b sein
    % 	        NOT b IFF stuff(s, n, b)(i)
	    
    
END bitstuffing
